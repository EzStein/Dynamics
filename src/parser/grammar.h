#ifndef DYNSOLVER_PARSER_GRAMMAR_H_
#define DYNSOLVER_PARSER_GRAMMAR_H_

#include <unordered_map>
#include <set>
#include <vector>

#include "parser/common.h"
#include "parser/lr_parser.h"

namespace dynsolver {
namespace parser {

// This class represents a context free grammar. A context free grammar is
// a set of terminal and nonterminals called grammar symbols along with
// a set of productions. Each nonterminal is associated with one or more
// productions, that is, an ordered sequence of grammar symbols.
//
// This grammar class is used to generated various parsers for the grammar.
// Some parsers cannot be generated by some grammars.
//
// The grammar is built using the add_production function.
// This function return a special object with an append_symbol
// method which allows us to build the production by specifying
// its sequence of symbols.
//
// Grammar symbols are represented using integers. In general, an enumeration
// type or class with public static integers is used for grammar symbols.
// Note that an enum class does not have implicit integer conversion so may
// not be ideal. There are no restrictions on which integers may be tokens.
//
// The special grammar symbol denoted as epsilon can be specified by calling
// the add_production functions without appending any symbols.
//
// No checks are made to ensure that the built grammar is well formed
// until a call to generate a parser is made.
//
// The start nonterminal for the grammar is assumed to be the nonterminal
// associated with the production that was last added.
//
// Example use for the following grammar:
//
// E -> epsilon
// E -> E + F
// E -> E - F
// E -> F
// F -> F * B
// F -> F / B
// F -> B
// B -> ( E )
//
// Suppose symbol is a class with public const static integer members
// EXPRESSION, FACTOR, BASE, PLUS, MINUS, TIMES, DIVIDE, LEFT_PAREN
// and RIGHT_PAREN. Then the following code generates the grammar.
//
// grammar expressionGrammar;
// expressionGrammar.add_production(symbol::EXPRESSION)
//                       .done()
//                  .add_production(symbol::EXPRESSION)
//                       .append_symbol(symbol::EXPRESSION)
//                       .append_symbol(symbol::PLUS)
//                       .append_symbol(symbol::FACTOR)
//                       .done()
//                  .add_production(symbol::EXPRESSION)
//                       .append_symbol(symbol::EXPRESSION)
//                       .append_symbol(symbol::MINUS)
//                       .append_symbol(symbol::FACTOR)
//                       .done()
//                  .add_production(symbol::EXPRESSION)
//                       .append_symbol(symbol::FACTOR)
//                       .done()
//                  .add_production(symbol::FACTOR)
//                       .append_symbol(symbol::FACTOR)
//                       .append_symbol(symbol::TIMES)
//                       .append_symbol(symbol::BASE)
//                       .done()
//                  .add_production(symbol::FACTOR)
//                       .append_symbol(symbol::FACTOR)
//                       .append_symbol(symbol::DIVIDES)
//                       .append_symbol(symbol::BASE)
//                       .done()
//                  .add_production(symbol::FACTOR)
//                       .append_symbol(symbol::BASE)
//                       .done()
//                  .add_production(symbol::BASE)
//                       .append_symbol(symbol::LEFT_PAREN)
//                       .append_symbol(symbol::EXPRESSION)
//                       .append_symbol(symbol::RIGHT_PAREN)
//                       .done();
//
// Note that it is not actually necessary to specify .done() to
// finishing building a production. Instead, you could simply end the statement
// use expressionGrammar.add_production(...).
//
// Note that it is a bad idea to store any of the returned references.
// In particular, do not ever store a reference returned from append_symbol
// since calls to add_production change the state of the returned reference.
//
//
// The nomenclature found in literature on parsers is somewhat confusing for
// a beginner. Often the same terms mean different things in different texts.
// There are two wide classes of grammers which are often parsed differently.
//
// LL refers to top-down parsing, that is, an algorithm which produces a pre-order
// traversal of the parse tree. Often times LL gramers are parsed using 
// recursive descent or table driven parsing. An LL(k) parser uses k tokens of
// lookahead before determining which production to use for the parse. Top-down
// parsers also may have backtracking capabilities (both recursive descent and
// table driven parsers can use this) but the grammer it parsers may not be
// considered an LL(k) grammar. Thus the following words all refer to the
// same idea: LL(k), top-down, bactracking recursive descent,
// predictive/deterministic recursive descent, top-down table driven,
// pre-order traversal. To construct a table driven LL(1) parser for a grammar
// the grammar must not be left recursive or ambiguous. Additionally,
// the grammar must be left factored. It is often possible to take
// a grammar and form an equivalent grammar which is unambiguous, left-factored,
// and non-left-recursive. It can be shown that LL(1) grammars are of this
// form. Additionally, certain other restrictions apply.
//
// LR refers to bottom-up parsing and produces a post order traversal of the
// parse tree. LR(k) uses k tokens of lookahead. Precedence and operator
// precedence parsers are some types of bottom up parsers. Bottom up parsing
// is commonly called shift-reduce parsing. It functions by reducing the input
// string to the start nonterminal in the grammar. In doing so, it constructs
// a derivation in reverse. When we read the input from left to right,
// we attempt to reduce the leftmost symbols. The derivation that is constructed
// is thus a rightmost derivation.
class grammar {
 public:
  // Default constructor which represents a grammar with no nonterminals
  // and no productions.
  grammar();

  // This class is used to build productions for a specific nonterminal.
  // It has two public methods. One appends the production to the appropriate
  // nonterminal and the other returns a reference to the original grammar
  // to indicate we are done with building the production.
  class production_builder {
   private:
    // A reference to the underlying grammar.
    grammar& ref;

    // A pointer to the production which we are appending to.
    std::vector<int>* productionArrayPointer;
    
    // The production with a reference to the grammar that contains it.
    production_builder(grammar& ref);
    
    friend class grammar;    
   public:
    // Appends the symbol to the production we are currently building.
    // Returns a reference to itself so the calls can be chained.
    production_builder& append_symbol(int symbol);

    // Returns a reference to the original grammar so that calls can be chained.
    grammar& done();
  };

  // Adds a production for the provided nonterminal (creates a new entry if
  // no productions exist). The result is a production object which can be
  // used to build the specific production desired. This function also sets
  // the start symbol to be the provided nonterminal.
  production_builder& add_production(int nonterminal);

  // Returns an lr parser for SLR grammars.
  // If the grammar is not SLR, an exception is thrown indicating the exact
  // problem.
  lr_parser generate_slr() const;

  // Sets the start symbol for this grammar. No checks are performed to ensure
  // that the start symbol is indeed a nonterminal. Note that any call to
  // add_production after calling this method will reset the start symbol.
  grammar& set_start(int nonterminal);
  
 private:
  // Whenever a symbol is added, we add it our set of symbols.
  std::set<int> symbols;

  // These are the values in the firstFollowMap. It contains a set of first
  // and a set of follow symbols. The bool value indicates whether the
  // first set contains an epsilon.
  struct first_follow_set {
    // The default constructor initializes first follow and epsilon to
    // empty sets and false.
    first_follow_set() : epsilon(false) { };
    std::set<int> first;
    bool epsilon;
    std::set<int> follow;
  };

  // Maps nonterminals to their first and follow sets.
  mutable std::unordered_map<int, first_follow_set> firstFollowMap;
  
  // Currently we implement the grammar as follows.
  // A map will associate each nonterminal symbol to an array of
  // productions. Each production is itself an array of grammar symbols.
  // We use an unordered_map for efficient lookup.
  std::unordered_map<int, std::vector<std::vector<int> > > grammarTable;

  // Each grammar has exactly one production builder which is constructed
  // with a reference to the original grammar. The production builder is
  // returned in a call to add_production().
  production_builder productionBuilder;

  // The start nonterminal.
  int start;

  // An item is a production with a pointer in the body. The pointer indicates
  // that the input is derivable from the set of grammar symbols up and excluding
  // that point. If the pointer is 0, we have not yet seen any input derivable
  // from the symbols in the production. If pointer is 1, the input is derivable
  // from the first symbol (but not the others). If pointer is body.size() then
  // it is derivable from the whole body.
  struct item {
    int head;
    std::vector<int> body;
    int pointer;
    int productionIndex;

    // We implement the < operator so that we may store items in a std::set.
    // If a and b are items then a < b => b < a iff a and b are not identical.
    // In particular, if a and b are equivalent then a < b is false and
    // b < a is false.
    bool operator<(item other) const {
      return (head < other.head)
          || (head == other.head && body < other.body)
          || (head == other.head && body == other.body && pointer < other.pointer);
    }
  };

  // Indicates whether the symbol is a terminal symbol. It is a terminal if
  // it is not the head of a production in the grammar.
  bool is_terminal(int symbol) const;

  // Indicates whether the symbol is a nonterminal. It is a nonterminal if
  // it is the head of a production in the grammar.
  bool is_nonterminal(int symbol) const;

  // Computes the set items given by a transition on the given symbol.
  // Only kernal items are computed. The closure is not.
  std::set<item> move_to(const std::set<item>& set, int symbol) const;
  
  // Computes the closure set of the provided item. This is the set of items
  // whose heads are nonterminals pointed to by an item in that set.
  // The set that is passed in is populated with the extra items so that
  // it is closed.
  //
  // We iterate over the list of items, adding in new items each time
  // until an iteration adds no more new items.
  void compute_closure(std::set<item>& set) const;

  // Consults the firstFollowMap and returns the follow set for the provided
  // symbol. Performs no checks on the input. This function should only
  // be called after compute_first_follow().
  std::set<int> follow(int symbol) const;

  // Consults the firstFollowMap and returns the first set for the provided
  // symbol. Performs no checks on the input. This function should only
  // be called after compute_first_follow().
  std::set<int> first(int symbol) const;

  // Computes the first and follow sets for each grammar symbol storing the result
  // in first follow map.
  void compute_first_follow() const;
};
} // namespace parser
} // namespace dynsolver

#endif
