#ifndef DYNSOLVER_PARSER_GRAMMAR_H_
#define DYNSOLVER_PARSER_GRAMMAR_H_

#include "parser/common.h"
#include "parser/lr_parser.h"

#include <map>
#include <vector>

namespace dynsolver {
namespace parser {

// This class represents a context free grammar. A context free grammar is
// a set of terminal and nonterminals called grammar symbols along with
// a set of productions. Each nonterminal is associated with one or more
// productions, that is, an ordered sequence of grammar symbols.
//
// This grammar class is used to generated various parsers for the grammar.
// Some parsers cannot be generated by some grammars.
//
// The grammar is built using the add_production function.
// This function return a special object with an append_symbol
// method which allows us to build the production by specifying
// its sequence of symbols.
//
// Grammar symbols are represented using integers. In general, an enumeration
// type or class with public static integers is used for grammar symbols.
// Note that an enum class does not have implicit integer conversion so may
// not be ideal. There is no restriction as to which integers can be associated
// to grammar symbols.
//
// The special grammar symbol denoted as epsilon can be specified by calling
// the add_production functions without appending any symbols.
//
// No checks are made to ensure that the built grammar is well formed.
//
// The start nonterminal for the grammar is assumed to be the nonterminal
// associated with the production that was last added.
//
// Example use for the following grammar:
//
// E -> epsilon
// E -> E + F
// E -> E - F
// E -> F
// F -> F * B
// F -> F / B
// F -> B
// B -> ( E )
//
// Suppose symbol is a class with public const static integer members
// EXPRESSION, FACTOR, BASE, PLUS, MINUS, TIMES, DIVIDE, LEFT_PAREN
// and RIGHT_PAREN. Then the following code generates the grammar.
//
// grammar expressionGrammar;
// expressionGrammar.add_production(symbol::EXPRESSION)
//                       .done()
//                  .add_production(symbol::EXPRESSION)
//                       .append_symbol(symbol::EXPRESSION)
//                       .append_symbol(symbol::PLUS)
//                       .append_symbol(symbol::FACTOR)
//                       .done()
//                  .add_production(symbol::EXPRESSION)
//                       .append_symbol(symbol::EXPRESSION)
//                       .append_symbol(symbol::MINUS)
//                       .append_symbol(symbol::FACTOR)
//                       .done()
//                  .add_production(symbol::EXPRESSION)
//                       .append_symbol(symbol::FACTOR)
//                       .done()
//                  .add_production(symbol::FACTOR)
//                       .append_symbol(symbol::FACTOR)
//                       .append_symbol(symbol::TIMES)
//                       .append_symbol(symbol::BASE)
//                       .done()
//                  .add_production(symbol::FACTOR)
//                       .append_symbol(symbol::FACTOR)
//                       .append_symbol(symbol::DIVIDES)
//                       .append_symbol(symbol::BASE)
//                       .done()
//                  .add_production(symbol::FACTOR)
//                       .append_symbol(symbol::BASE)
//                       .done()
//                  .add_production(symbol::BASE)
//                       .append_symbol(symbol::LEFT_PAREN)
//                       .append_symbol(symbol::EXPRESSION)
//                       .append_symbol(symbol::RIGHT_PAREN)
//                       .done();
//
// Note that it is not actually necessary to specify .done() to
// finishing building a production. Instead, you could simply end the statement
// use expressionGrammar.add_production(...).
//
// Note that it is a bad idea to store any of the returned references.
// In particular, do not ever store a reference returned from append_symbol
// since calls to add_production change the state of the returned reference.
class grammar {
 public:
  // Default constructor which represents a grammar with no nonterminals
  // and no productions.
  grammar();

  // This class is used to build productions for a specific nonterminal.
  // It has two public methods. One appends the production to the appropriate
  // nonterminal and the other returns a reference to the original grammar
  // to indicate we are done with building the production.
  class production_builder {
   private:
    // A reference to the underlying grammar.
    grammar& ref;

    // A pointer to the production which we are appending to.
    std::vector<int>* productionArrayPointer;
    
    // The production with a reference to the grammar that contains it.
    production_builder(grammar& ref);
    
    friend class grammar;    
   public:
    // Appends the symbol to the production we are currently building.
    // Returns a reference to itself so the calls can be chained.
    production_builder& append_symbol(int symbol);

    // Returns a reference to the original grammar so that calls can be chained.
    grammar& done();
  };

  // Adds a production for the provided nonterminal (creates a new entry if
  // no productions exist). The result is a production object which can be
  // used to build the specific production desired. This function also sets
  // the start symbol to be the provided nonterminal.
  production_builder& add_production(int nonterminal);

  // Returns an lr parser for LR0 grammars.
  // If the grammar is not LR0, an exception is thrown indicating the exact
  // problem.
  lr_parser generate_lr0() const;
  
 private:
  // Whenever a symbol is added, we add it our set of symbols.
  std::set<int> symbols;
  
  // Currently we implement the grammar as follows.
  // A map will associate each nonterminal symbol to an array of
  // productions. Each production is itself an array of grammar symbols.
  // We use an unordered_map for efficient lookup.
  std::unordered_map<int, std::vector<std::vector<int> > > grammarTable;

  // Each grammar has exactly one production builder which is constructed
  // with a reference to the original grammar. The production builder is
  // returned in a call to add_production().
  production_builder productionBuilder;

  // The start nonterminal.
  int start;

  // An item is a production with a pointer in the body. The pointer indicates
  // that the input is derivable from the set of grammar symbols up and excluding
  // that point. If the pointer is 0, we have not yet seen any input derivable
  // from the symbols in the production. If pointer is 1, the input is derivable
  // from the first symbol (but not the others). If pointer is body.size() then
  // it is derivable from the whole body.
  struct item {
    int head;
    std::vector<int> body;
    int pointer;

    // We implement the < operator so that we may store items in a std::set.
    // If a and b are items then a < b => b < a iff a and b are not identical.
    // In particular, if a and b are equivalent then a < b is false and
    // b < a is false.
    bool operator<(item other) {
      return (head < other.head)
          || (head == other.head && body < other.body)
          || (head == other.head && body == other.body && pointer < other.pointer);
    }
  };

  // Indicates whether the symbol is a terminal symbol. It is a terminal if
  // it is not the head of a production in the grammar.
  bool is_terminal(int symbol) const;

  // Indicates whether the symbol is a nonterminal. It is a nonterminal if
  // it is the head of a production in the grammar.
  bool is_nonterminal(int symbol) const;

  // Computes the set items given by a transition on the given symbol.
  std::set<item> move_to(const std::set<item>& set, int symbol) const;
  
  // Computes the closure set of the provided item. This is the set of items
  // whose heads are nonterminals pointed to by an item in that set.
  // The set that is passed in is populated with the extra items so that
  // it is closed.
  //
  // We iterate over the list of items, adding in new items each time
  // until an iteration adds no more new items.
  void closure(std::set<item>& set) const;
};
} // namespace parser
} // namespace dynsolver
